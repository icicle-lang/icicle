############
### Base ###
############

# mod, relying on rounding.
mod x y
  = x - (trunc (double x / double y) * y).

# integer division
int_div x y
  = trunc (double x / double y).

# Time statements
newest v = fold1 s = v : v ~> s.
oldest v = fold1 s = v : s ~> s.

# check if a day is a weekend.
is_weekend v
  =  let day = mod (days v) 7
  ~> day == 3 || day == 4.

# starting at epoch 1600/01/03, identify the week that containing this day.
week_of_day d
  = trunc (double (days d) / 7).

# Boolean statements
not a = case a | True -> False | False -> True end.

is_some a = case a | Some _ -> True  | None -> False end.
is_none a = case a | Some _ -> False | None -> True  end.

get a = case a | Some a' -> a' | None -> box (Left ExceptTombstone) end.

get_or_else default a  = case a | Some a' -> a' | None -> default end.

fst x = case x | (a,b) -> a end.
snd x = case x | (a,b) -> b end.

group_keys k = keys (group k ~> 0).

# This only works if inlining is set to with-subst (:set inline with-subst in the REPL)
group_vals k v = vals (group k ~> v).

return v = newest v.

# Are any elements true
any x = fold a = False : a || x ~> a.

# Are all elements true
all x = fold a = True : a && x ~> a.

##################
### Statistics ###
##################

sum v = fold s = 0 : v + s ~> s.
count v = fold c = 0 : seq v (c + 1) ~> c.

# Numerically stable mean
mean v =
   let
     v_ =
       double v
~> fold1 (m, n) = (v_, 1) : m + (v_ - m) / (n + 1), n + 1
~> m.

max v = fold1 s = v : case v > s | True -> v | False -> s end ~> s.
min v = fold1 s = v : case v < s | True -> v | False -> s end ~> s.

min_by a b =
 fold1 (a1, b1)
   = (a, b)
   : case a < a1 | True -> (a,b) | False -> (a1,b1) end
~> b1.

max_by a b =
 fold1 (a1, b1)
   = (a, b)
   : case a > a1 | True -> (a,b) | False -> (a1,b1) end
   ~> b1.

# Numerically stable variance
variance v =
  let
    v_ =
      double v

~> fold (n, m, m2)
     = (0, 0, 0)
     : (
       let nn = n + 1 ~>
       let d = v_ - m ~>
       let mm = m + d / nn ~>
       let m22 = m2 + d * (v_ - mm) ~>
       (nn, mm, m22)
       )
~> m2 / (n - 1).

sd v = sqrt (variance v).

# Numerically stable covariance
covariance a b =
  let a_ = double a ~>
  let b_ = double b ~>
  fold (n,m1,m2,m12) = (0, 0.0, 0.0, 0.0)
     : (
        let nn  = n + 1 ~>
        let d1 = (a_ - m1) / nn ~>
        let mm1 = m1 + d1 ~>
        let d2 = (b_ - m2) / nn ~>
        let mm2 = m2 + d2 ~>
        let mm12 = m12 + n * d1 * d2 - m12 / nn ~>
        (nn, mm1, mm2,mm12)
        )
     ~> m12 * n / (n - 1).

# Pearson's product-moment correlation coefficient.
correlation a b = covariance a b / (sd a * sd b).

# Gradient with units y/x.
gradient a b = covariance a b / variance b.

# Version of num flips which should fail upon finding a tombstone value.
numflips v = fold1 (s,i) = (v,0) : case (s == v) | True -> (v,i) | False -> (v,i+1) end ~> i.

# Version of num flips which will accommodate tombstone values. Must have the tombstone feature passed to it.
numflips' v t
 = fold1 s
   = case t | True ->  (None,0) | False -> (Some(v),0) end
   : case t | True  -> (case s | (Some(s0),i) -> (None,i+1)
                               | (None,i) -> (None,i)
                               end )
            | False -> (case s | (Some(s0),i) ->
                                    (case (s0 == v) | True -> (Some(v),i) | False -> (Some(v),i+1) end)
                               | (None,i) -> (Some(v),i+1)
                               end )
          end
 ~> case s | (s0,i) -> i end.

#######################
### Example queries ###
#######################

# Quantiles from a sorted array of ints, same as in R.
# TODO safe array_index in Source that maps to unsafe index in Avalanche
# (might need a function unbox :: Sum Error a -> Option a)
quantile_on_sorted p array
 = case (p >= 0 && p <= 1)
    | True
    -> (  let len          = length array
       ~> let actual       = p * (double (len - 1))
       ~> let actual_ceil  = ceil  actual
       ~> let actual_floor = floor actual
       ~> let floor_weight = double actual_ceil - actual
       ~> let val_floor    = index array actual_floor
       ~> let val_ceil     = index array actual_ceil
       ~> let x            = double val_floor * floor_weight
       ~> let y            = double val_ceil  * double (1 - floor_weight)
       ~> Some (x + y))
    | False
    -> None
   end.

# Helper function for 'days_in' below
map_update_days_in state previous_time current_time state_days =
  let
    n =
      days between previous_time current_time
  ~>
  case map_lookup state state_days
  | None ->
      map_insert state n state_days
  | Some n0 ->
      map_insert state (n0 + n) state_days
  end.

# Count the days that an entity has spent in different states.
# e.g. days_in state time now = [("NSW", 20), ("QLD", 1)]
days_in state fact_time query_time =
  fold1
    stm =
        ((state, fact_time), map_create)
      : case stm | ((s, t), m) ->
          ((state, fact_time), map_update_days_in s t fact_time m)
        end
  ~>
  case stm | ((s, t), m) ->
    map_update_days_in s t query_time m
  end.

# The offsets (in days) of facts.
date_offset_days time
 =  fold1 offsets
     = (map_insert 0 0 map_create, time)
     : (  let begin = snd offsets
       ~> let map   = fst offsets
       ~> let ds    = days between begin time
       ~> (map_insert ds 0 map, begin))
 ~> keys (fst offsets).

# The offsets (in weeks) of facts.
date_offset_weeks time
 =  fold1 offsets
     = (map_insert 0 0 map_create, time)
     : (  let begin = snd offsets
       ~> let map   = fst offsets
       ~> let ds    = round (double (days between begin time) / 7)
       ~> (map_insert ds 0 map, begin))
 ~> keys (fst offsets).
